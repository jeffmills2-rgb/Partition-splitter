<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Partition Splitter – Group Input Version</title>
<style>
:root {
  --cell-width: 150px;
  --cell-height: 180px;
  --border-color: #444;
  --label-color: #333;
  --digit-color: #0066cc; /* final / standard-form digits (blue) */
}

/* GLOBAL ---------------------------------------------------------- */
body {
  margin: 0;
  padding: 20px;
  background: #f6f7fb;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  color: #111827;
}

h1 {
  margin: 0;
  font-size: 2rem;
}

/* Small instruction line above the card */
.page-instruction {
  margin: 0 0 8px 4px;
  font-size: 1rem;
  color: #111827;
}

.app-container {
  max-width: 1200px;
  margin: 0 auto;
  background: #fff;
  padding: 24px;
  border-radius: 16px;
  box-shadow: 0 4px 18px rgba(0,0,0,0.08);
}

/* HEADER: title + mode toggle ------------------------------------ */
.app-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 16px;
  margin-bottom: 16px;
}

.mode-toggle {
  display: inline-flex;
  background: #e5e7eb;
  border-radius: 999px;
  padding: 3px;
}

.mode-toggle button {
  border: none;
  background: transparent;
  padding: 6px 14px;
  font-size: 0.9rem;
  border-radius: 999px;
  cursor: pointer;
  color: #4b5563;
  transition: all 0.15s ease-out;
}

.mode-toggle button.active {
  background: #2563eb;
  color: #fff;
}

/* ACTION BUTTON ROW ---------------------------------------------- */
.action-row {
  margin-top: 12px;
  display: flex;
  justify-content: flex-end;
  gap: 10px;
}

.action-row button {
  border: none;
  border-radius: 999px;
  padding: 8px 18px;
  font-size: 0.95rem;
  cursor: pointer;
}

#resetBtn {
  background: #e5e7eb;
  color: #111827;
}

#animateBtn {
  background: #10b981;
  color: #ffffff;
}

#returnBtn {
  background: #e5e7eb;
  color: #111827;
}

#enterBtn {
  background: #2563eb;
  color: #fff;
}

.hidden { display: none; }

/* ERROR MESSAGE --------------------------------------------------- */
#errorMessage {
  margin-top: 6px;
  color: #b91c1c;
  font-size: 0.9rem;
  display: none;
}

/* PLACE VALUE GRID ------------------------------------------------ */
.pv-wrapper {
  margin-top: 10px;
  margin-bottom: 12px;   /* extra space above buttons */
  padding: 16px;
  background: #f9faff;
  border-radius: 12px;
  border: 1px solid #dbe1f0;
}

.pv-grid {
  display: flex;
}

.pv-column {
  flex: 1;
  min-width: var(--cell-width);
  display: flex;
  flex-direction: column;
}

.pv-cell {
  border: 1px solid var(--border-color);
  border-right: none;
  display: flex;
  justify-content: center;
  align-items: center;
  background: #fff;
  position: relative; /* for bubbles & annotations */
}

.pv-column:last-child .pv-cell {
  border-right: 1px solid var(--border-color);
}

.pv-label {
  height: 150px;
}

.pv-label span {
  transform: rotate(-90deg);
  display: inline-block;
  font-size: 0.9rem;
  color: var(--label-color);
}

/* digit / standard cells ----------------------------------------- */
.pv-digit {
  height: var(--cell-height);
  font-size: 3rem;
  font-weight: 700;
  color: var(--digit-color); /* blue */
}

.pv-digit.empty {
  color: transparent;
}

/* image row cells ------------------------------------------------- */
.pv-image {
  height: 110px;              /* how tall the image cell is */
}

.pv-image-inner {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* THIS controls the picture size */
.pv-image-inner img {
  max-height: 70%;
  max-width: 70%;
  height: auto;
  width: auto;
  object-fit: contain;
}

/* INPUT MODE: invisible input + coloured overlay ----------------- */
.pv-input {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  border: none;
  outline: none;
  text-align: center;
  font-size: 2.6rem;
  font-weight: 700;
  background: transparent;
  color: transparent;         /* text itself hidden */
  caret-color: #2563eb;       /* caret still visible */
}

.pv-input::placeholder {
  color: #d1d5db;
}

.pv-input-display {
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 2.6rem;
  font-weight: 700;
  pointer-events: none;
}

.pv-multi-red {
  color: #e11d48;  /* red for tens/hundreds groups */
}

.pv-multi-blue {
  color: var(--digit-color); /* blue for ones digit */
}

/* highlight on split --------------------------------------------- */
.pv-column.split-left .pv-digit {
  border-right: 4px solid #2563eb;
}

/* CARRY ANIMATION ------------------------------------------------- */
.carry-bubble {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 4rem;
  font-weight: 700;
  color: #e11d48;
  pointer-events: none;
  animation: move-left 3.2s ease-out forwards;
}

.carry-annotation {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 1.5rem;
  font-weight: 700;
  color: #e11d48;
  background: rgba(255,255,255,0.98);
  padding: 6px 14px;
  border-radius: 8px;
  pointer-events: none;
  white-space: nowrap;
  animation: fade-out 3.2s ease-out forwards;
}

@keyframes move-left {
  from {
    transform: translate(-50%, -50%);
    opacity: 1;
  }
  to {
    transform: translate(calc(-50% + var(--dx, -150%)), -50%);
    opacity: 0;
  }
}

@keyframes fade-out {
  0%   { opacity: 1; }
  80%  { opacity: 1; }
  100% { opacity: 0; }
}

/* SLIDER ---------------------------------------------------------- */
.split-slider-row {
  margin-top: 14px;
  text-align: center;
}

.split-slider-label {
  font-size: 0.95rem;
  color: #4b5563;
  margin-bottom: 4px;
}

.split-slider-container {
  width: calc(100% - 32px);
  margin-left: 16px;
  margin-right: 16px;
  position: relative;
}

#splitSlider {
  width: 83%;
  margin-left: 16%;
  height: 6px;
  background: #d1d5db;
  border-radius: 999px;
  appearance: none;
  outline: none;
}

#splitSlider::-webkit-slider-thumb {
  appearance: none;
  width: 24px;
  height: 24px;
  border-radius: 50%;
  background: #2563eb;
  border: 3px solid #ffffff;
  box-shadow: 0 0 0 2px rgba(37,99,235,0.4);
  cursor: pointer;
}
#splitSlider::-moz-range-thumb {
  width: 24px;
  height: 24px;
  border-radius: 50%;
  background: #2563eb;
  border: 3px solid #ffffff;
  box-shadow: 0 0 0 2px rgba(37,99,235,0.4);
  cursor: pointer;
}

/* RESULT TEXT ----------------------------------------------------- */
.result-row {
  margin-top: 18px;
  background: #fff7dd;
  border: 1px dashed #facc8a;
  padding: 16px;
  border-radius: 12px;
  font-size: 1.2rem;
}

.result-row .number {
  color: #1d4ed8;
  font-weight: 700;
}

/* VISUAL BLOCKS --------------------------------------------------- */
.visuals-row {
  margin-top: 40px;
  display: flex;
  gap: 24px;
  justify-content: space-around;
  flex-wrap: wrap;
}

.visual-block {
  flex: 1 1 300px;
  max-width: 380px;
  text-align: center;
}

.visual-title {
  font-size: 1.3rem;
  font-weight: 700;
  margin-bottom: 0;
}

.visual-inner {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 28px;
  margin-top: 72px;
}

.unit-image-wrapper {
  max-width: 100%;
  height: 230px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.unit-image-wrapper.wide {
  height: 300px;
}

.unit-image-wrapper img {
  max-width: 100%;
  height: auto;
}

.unit-image-wrapper.ones img {
  max-width: 80px;
}

.visual-multiplier {
  font-size: 2.4rem;
  font-weight: 700;
  font-family: "Comic Neue", "Comic Sans MS", "Marker Felt", cursive,
    system-ui, -apple-system, sans-serif;
  white-space: nowrap;
  flex-shrink: 0;
}

/* CHALLENGE PANEL ------------------------------------------------- */
.challenge-note {
  margin-top: 4px;
  font-size: 0.9rem;
  color: #4b5563;
}

#revealBtn {
  margin-top: 10px;
  padding: 8px 16px;
  border-radius: 999px;
  border: none;
  background: #2563eb;
  color: white;
  font-size: 0.95rem;
  cursor: pointer;
}

#revealBtn:disabled {
  opacity: 0.7;
  cursor: default;
}

/* RESPONSIVE ------------------------------------------------------ */
@media (max-width: 800px) {
  :root {
    --cell-width: 110px;
    --cell-height: 150px;
  }
  .pv-label { height: 140px; }
  .pv-digit { font-size: 2.3rem; }
  .pv-input-display { font-size: 2.1rem; }
  .unit-image-wrapper {
    height: 190px;
  }
  .unit-image-wrapper.wide {
    height: 240px;
  }
  .visual-multiplier {
    font-size: 2rem;
  }
}
</style>
</head>
<body>

<p class="page-instruction">
  Enter values for each place value to build your number.
</p>

<div class="app-container">

  <div class="app-header">
    <h1>Partition Splitter</h1>
    <div class="mode-toggle">
      <button id="exploreBtn" class="active">Explore</button>
      <button id="challengeBtn">Challenge</button>
      <button id="flashBtn">Flash cards</button>
    </div>
  </div>

  <!-- PLACE VALUE GRID -->
  <div class="pv-wrapper">
    <div id="pvGrid" class="pv-grid"></div>
  </div>

  <!-- BUTTONS -->
  <div class="action-row">
    <button id="resetBtn">Reset</button>
    <button id="animateBtn">Animate</button>
    <button id="returnBtn" class="hidden">Return to input</button>
    <button id="enterBtn">Enter</button>
  </div>

  <div id="errorMessage"></div>

  <!-- SLIDER (hidden until Enter/Animate pressed) -->
  <div id="sliderRow" class="split-slider-row hidden">
    <div class="split-slider-label">Drag to choose a split:</div>
    <div class="split-slider-container">
      <input type="range" id="splitSlider" min="0" max="5" value="3" />
    </div>
  </div>

  <!-- RESULT + VISUALS -->
  <div id="resultRow" class="result-row hidden" aria-live="polite"></div>

  <div id="visualsRow" class="visuals-row hidden">
    <div class="visual-block" id="leftVisualBlock">
      <div class="visual-title" id="leftVisualTitle"></div>
      <div class="visual-inner">
        <div class="unit-image-wrapper" id="leftImageWrapper"></div>
        <div class="visual-multiplier" id="leftMultiplier"></div>
      </div>
    </div>
    <div class="visual-block" id="rightVisualBlock">
      <div class="visual-title" id="rightVisualTitle"></div>
      <div class="visual-inner">
        <div class="unit-image-wrapper ones" id="rightImageWrapper"></div>
        <div class="visual-multiplier" id="rightMultiplier"></div>
      </div>
    </div>
  </div>

</div>

<script>
const placeNames = [
  "hundred-thousands",
  "ten-thousands",
  "thousands",
  "hundreds",
  "tens",
  "ones"
];

const placeValues = [100000, 10000, 1000, 100, 10, 1];

// small base-10 images for the extra row
const base10Images = {
  0: "img-hundred-thousands.png",
  1: "img-ten-thousands.png",
  2: "img-thousands.png",
  3: "img-hundreds.png",
  4: "img-tens.png",
  5: "img-ones.png"
};

const gridEl = document.getElementById("pvGrid");
const errorEl = document.getElementById("errorMessage");
const sliderRow = document.getElementById("sliderRow");
const splitSlider = document.getElementById("splitSlider");
const resultRow = document.getElementById("resultRow");
const visualsRow = document.getElementById("visualsRow");
const leftVisualBlock = document.getElementById("leftVisualBlock");
const rightVisualBlock = document.getElementById("rightVisualBlock");
const leftVisualTitle = document.getElementById("leftVisualTitle");
const rightVisualTitle = document.getElementById("rightVisualTitle");
const leftImageWrapper = document.getElementById("leftImageWrapper");
const rightImageWrapper = document.getElementById("rightImageWrapper");
const leftMultiplier = document.getElementById("leftMultiplier");
const rightMultiplier = document.getElementById("rightMultiplier");
const exploreBtn = document.getElementById("exploreBtn");
const challengeBtn = document.getElementById("challengeBtn");
const flashBtn = document.getElementById("flashBtn");
const enterBtn = document.getElementById("enterBtn");
const returnBtn = document.getElementById("returnBtn");
const resetBtn = document.getElementById("resetBtn");
const animateBtn = document.getElementById("animateBtn");

let isInputMode = true;
let currentMode = "explore";
let currentValue = null;
let challengeRevealed = false;
let originalInputs = new Array(placeNames.length).fill("");
let finalCounts = new Array(placeNames.length).fill(0);

// live counts while typing (for image row in input mode)
let inputCounts = new Array(placeNames.length).fill(0);

// animation state for reversible regroup
let isAnimating = false;
let hasAnimated = false;
let animationSteps = []; // recorded forward steps for undo

/* UTILITIES ------------------------------------------------------- */
function formatWithSpaces(n) {
  return n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, " ");
}

function setError(msg) {
  if (msg) {
    errorEl.style.display = "block";
    errorEl.textContent = msg;
  } else {
    errorEl.style.display = "none";
    errorEl.textContent = "";
  }
}

function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

function setSliderEnabled(enabled) {
  splitSlider.disabled = !enabled;
  splitSlider.style.opacity = enabled ? "1" : "0.4";
}

/* IMAGE ROW HELPERS ---------------------------------------------- */
/* show images for every non-leading place between
   the first and last non-zero digit. */
function refreshImageRowForCounts(counts) {
  const cols = gridEl.querySelectorAll(".pv-column");
  if (!cols.length) return;

  const len = counts.length;
  const allZero = counts.every(v => v === 0);

  // if everything is zero, keep the whole image row blank
  if (allZero) {
    for (let i = 0; i < len; i++) {
      const imgCell = cols[i].querySelector(".pv-image");
      if (imgCell) imgCell.innerHTML = "";
    }
    return;
  }

  let firstNonZero = -1;
  let lastNonZero = -1;
  for (let i = 0; i < len; i++) {
    if (counts[i] !== 0 && firstNonZero === -1) firstNonZero = i;
    if (counts[i] !== 0) lastNonZero = i;
  }
  if (firstNonZero === -1) {
    firstNonZero = len - 1;
    lastNonZero = len - 1;
  }

  for (let i = 0; i < len; i++) {
    const imgCell = cols[i].querySelector(".pv-image");
    if (!imgCell) continue;
    imgCell.innerHTML = "";

    // hide true leading zeros and far-right unused places
    if (i < firstNonZero || i > lastNonZero) continue;

    // for non-leading places, ALWAYS show the base-10 image
    const wrapper = document.createElement("div");
    wrapper.className = "pv-image-inner";
    const img = document.createElement("img");
    img.src = base10Images[i];
    wrapper.appendChild(img);
    imgCell.appendChild(wrapper);
  }
}

/* INPUT DISPLAY (red groups + blue ones) ------------------------- */
function updateInputDisplay(index, value) {
  const display = gridEl.querySelector(
    `.pv-input-display[data-index="${index}"]`
  );
  if (!display) return;

  display.innerHTML = "";

  let str;
  if (value === 0 || value === "0") {
    str = "0";
  } else if (value === "" || value == null) {
    str = "";
  } else {
    str = String(value).trim();
  }

  if (!str) return;

  const len = str.length;
  for (let i = 0; i < len; i++) {
    const span = document.createElement("span");
    span.textContent = str[i];
    if (i === len - 1) {
      span.className = "pv-multi-blue";   // ones digit (blue)
    } else {
      span.className = "pv-multi-red";    // groups (red)
    }
    display.appendChild(span);
  }
}

/* GRID RENDERING -------------------------------------------------- */
function renderInputGrid() {
  gridEl.innerHTML = "";
  const places = placeNames.length;

  // rebuild inputCounts from originalInputs when returning to input
  inputCounts = new Array(places).fill(0);

  for (let i = 0; i < places; i++) {
    const col = document.createElement("div");
    col.className = "pv-column";

    const label = document.createElement("div");
    label.className = "pv-cell pv-label";
    label.innerHTML = `<span>${placeNames[i]}</span>`;

    const inputCell = document.createElement("div");
    inputCell.className = "pv-cell pv-digit";

    const input = document.createElement("input");
    input.type = "number";
    input.min = "0";
    input.max = "999";
    input.step = "1";
    input.className = "pv-input";
    input.dataset.index = i;

    // restore stored value (if any)
    if (originalInputs[i] !== "" && originalInputs[i] != null) {
      input.value = originalInputs[i];
      inputCounts[i] = Number(originalInputs[i]);
    } else {
      input.value = "";
    }

    const display = document.createElement("div");
    display.className = "pv-input-display";
    display.dataset.index = i;

    input.addEventListener("input", () => {
      input.value = input.value.replace(/\D/g, "");
      if (input.value.length > 3) {
        input.value = input.value.slice(0, 3);
      }

      if (input.value === "") {
        originalInputs[i] = "";
        inputCounts[i] = 0;
      } else {
        const n = Number(input.value);
        originalInputs[i] = n;
        inputCounts[i] = n;
      }

      updateInputDisplay(i, input.value);
      refreshImageRowForCounts(inputCounts);
    });

    inputCell.appendChild(input);
    inputCell.appendChild(display);

    // image row cell
    const imageCell = document.createElement("div");
    imageCell.className = "pv-cell pv-image";

    col.append(label, inputCell, imageCell);
    gridEl.append(col);

    // initial overlay display
    updateInputDisplay(i, input.value);
  }

  refreshImageRowForCounts(inputCounts);
}

function renderDigitGrid() {
  gridEl.innerHTML = "";
  if (currentValue === null) return;

  const places = placeNames.length;
  const counts = finalCounts || new Array(places).fill(0);

  // find first non-zero so leading places can be blanked
  let firstNonZero = counts.findIndex(v => v !== 0);
  if (firstNonZero === -1) {
    firstNonZero = places - 1; // show 0 in ones only
  }

  for (let i = 0; i < places; i++) {
    const col = document.createElement("div");
    col.className = "pv-column";

    const label = document.createElement("div");
    label.className = "pv-cell pv-label";
    label.innerHTML = `<span>${placeNames[i]}</span>`;

    const digitCell = document.createElement("div");
    digitCell.className = "pv-cell pv-digit";

    const val = counts[i];

    if (i < firstNonZero) {
      digitCell.textContent = "0";
      digitCell.classList.add("empty");
    } else {
      digitCell.textContent = String(val);
    }

    const imageCell = document.createElement("div");
    imageCell.className = "pv-cell pv-image";

    col.append(label, digitCell, imageCell);
    gridEl.append(col);
  }

  refreshImageRowForCounts(counts);
}

function renderGrid() {
  if (isInputMode) {
    renderInputGrid();
  } else {
    renderDigitGrid();
  }
  updateGridSplitHighlight();
}

/* SPLIT + PARTITION LOGIC ---------------------------------------- */
function updateGridSplitHighlight() {
  const cols = gridEl.querySelectorAll(".pv-column");
  cols.forEach(col => col.classList.remove("split-left"));

  if (isInputMode) return;
  if (currentMode === "challenge" && !challengeRevealed) return;

  const idx = Number(splitSlider.value);
  if (idx >= 0 && idx < cols.length) {
    cols[idx].classList.add("split-left");
  }
}

function getSplitData() {
  if (currentValue === null) return null;
  const idx = Number(splitSlider.value);
  const places = placeNames.length;
  const maxPower = places - 1;
  const power = maxPower - idx;
  const base = 10 ** power;
  const leftCount = Math.floor(currentValue / base);
  const rightCount = currentValue % base;
  const leftLabel = placeNames[idx].replace("-", " ");
  return { idx, leftCount, rightCount, leftLabel, places };
}

/* EXPLORE MODE ---------------------------------------------------- */
function updateExploreView() {
  if (currentValue === null) {
    resultRow.classList.add("hidden");
    return;
  }

  const data = getSplitData();
  if (!data) return;
  const { idx, leftCount, rightCount, leftLabel, places } = data;
  const formatted = formatWithSpaces(currentValue);
  const lastIndex = places - 1;

  if (idx === lastIndex) {
    resultRow.innerHTML = `
      <span class="number">${formatted}</span>
      is the same as
      <span class="number">${leftCount}</span> ones.
    `;
  } else if (rightCount === 0) {
    resultRow.innerHTML = `
      <span class="number">${formatted}</span>
      is the same as
      <span class="number">${leftCount}</span> ${leftLabel}.
    `;
  } else {
    resultRow.innerHTML = `
      <span class="number">${formatted}</span>
      is the same as
      <span class="number">${leftCount}</span> ${leftLabel}
      and
      <span class="number">${rightCount}</span> ones.
    `;
  }

  resultRow.classList.remove("hidden");

  leftVisualTitle.innerHTML = `<span class="number">${leftCount}</span> ${leftLabel}`;
  rightVisualTitle.innerHTML = `<span class="number">${rightCount}</span> ones`;

  leftImageWrapper.innerHTML = "";
  rightImageWrapper.innerHTML = "";

  leftImageWrapper.classList.toggle("wide", false);
  const leftImg = document.createElement("img");
  leftImg.src = base10Images[idx];
  leftImageWrapper.appendChild(leftImg);

  if (idx === lastIndex || rightCount === 0) {
    rightVisualBlock.classList.add("hidden");
    rightMultiplier.textContent = "";
  } else {
    rightVisualBlock.classList.remove("hidden");
    const r = document.createElement("img");
    r.src = base10Images[5]; // ones
    rightImageWrapper.appendChild(r);
  }

  leftMultiplier.textContent = `× ${leftCount}`;
  if (idx === lastIndex || rightCount === 0) {
    rightMultiplier.textContent = "";
  } else {
    rightMultiplier.textContent = `× ${rightCount}`;
  }

  visualsRow.classList.remove("hidden");
}

/* CHALLENGE MODE -------------------------------------------------- */
function buildChallengeRowHTML(show) {
  const data = getSplitData();
  if (!data) return "";
  const { idx, leftCount, rightCount, leftLabel, places } = data;
  const formatted = formatWithSpaces(currentValue);
  const lastIndex = places - 1;

  const L = show ? leftCount : "?";
  const R = show ? rightCount : "?";

  if (idx === lastIndex) {
    return `
      <span class="number">${formatted}</span>
      is the same as
      <span class="number">${L}</span> ones.
      <div class="challenge-note">
        Work out the number, then click <strong>Reveal</strong>.<br/>
        <button id="revealBtn"${show ? " disabled" : ""}>Reveal</button>
      </div>
    `;
  }

  if (rightCount === 0) {
    return `
      <span class="number">${formatted}</span>
      is the same as
      <span class="number">${L}</span> ${leftLabel}.
      <div class="challenge-note">
        Work out the number, then click <strong>Reveal</strong>.<br/>
        <button id="revealBtn"${show ? " disabled" : ""}>Reveal</button>
      </div>
    `;
  }

  return `
    <span class="number">${formatted}</span>
    is the same as
    <span class="number">${L}</span> ${leftLabel}
    and
    <span class="number">${R}</span> ones.
    <div class="challenge-note">
      Work out the numbers, then click <strong>Reveal</strong>.<br/>
      <button id="revealBtn"${show ? " disabled" : ""}>Reveal</button>
    </div>
  `;
}

function updateChallengeView() {
  if (currentValue === null) {
    resultRow.classList.add("hidden");
    visualsRow.classList.add("hidden");
    return;
  }

  resultRow.innerHTML = buildChallengeRowHTML(challengeRevealed);
  resultRow.classList.remove("hidden");

  const btn = document.getElementById("revealBtn");
  if (btn && !challengeRevealed) {
    btn.addEventListener("click", () => {
      challengeRevealed = true;
      updateAll();
    });
  }

  const data = getSplitData();
  if (!data) return;
  const { idx, leftCount, rightCount, leftLabel, places } = data;
  const lastIndex = places - 1;

  leftVisualTitle.innerHTML = `<span class="number">${challengeRevealed ? leftCount : "?"}</span> ${leftLabel}`;
  rightVisualTitle.innerHTML = `<span class="number">${challengeRevealed ? rightCount : "?"}</span> ones`;

  leftImageWrapper.innerHTML = "";
  rightImageWrapper.innerHTML = "";

  leftImageWrapper.classList.toggle("wide", false);
  const leftImg = document.createElement("img");
  leftImg.src = base10Images[idx];
  leftImageWrapper.appendChild(leftImg);

  if (idx === lastIndex || rightCount === 0) {
    rightVisualBlock.classList.add("hidden");
    rightMultiplier.textContent = "";
  } else {
    rightVisualBlock.classList.remove("hidden");
    const r = document.createElement("img");
    r.src = base10Images[5]; // ones
    rightImageWrapper.appendChild(r);
  }

  if (idx === lastIndex || rightCount === 0) {
    leftMultiplier.textContent = challengeRevealed ? `× ${leftCount}` : "× ?";
    rightMultiplier.textContent = "";
  } else {
    leftMultiplier.textContent = challengeRevealed ? `× ${leftCount}` : "× ?";
    rightMultiplier.textContent = challengeRevealed ? `× ${rightCount}` : "× ?";
  }

  visualsRow.classList.remove("hidden");
}

/* UPDATE ALL ------------------------------------------------------ */
function updateAll() {
  renderGrid();
  if (isInputMode) {
    resultRow.classList.add("hidden");
    visualsRow.classList.add("hidden");
    return;
  }

  updateGridSplitHighlight();

  if (currentMode === "explore") {
    updateExploreView();
  } else {
    updateChallengeView();
  }
}

/* INPUT + REGROUPING ---------------------------------------------- */
function readInputCounts() {
  const inputs = gridEl.querySelectorAll(".pv-input");
  if (inputs.length !== placeNames.length) {
    return { ok: false, error: "Grid not ready." };
  }

  const raw = [];
  const counts = [];
  let nonZeroSeen = false;

  for (let i = 0; i < inputs.length; i++) {
    const txt = inputs[i].value.trim();
    if (txt === "") {
      raw.push("");
      counts.push(0);
      continue;
    }
    const n = Number(txt);
    if (!Number.isFinite(n) || n < 0 || !Number.isInteger(n)) {
      return { ok: false, error: "Please use whole numbers (0–999) in each column." };
    }
    if (n > 999) {
      return { ok: false, error: "No more than three digits (0–999) allowed in each cell." };
    }
    raw.push(n);
    counts.push(n);
    if (n !== 0) nonZeroSeen = true;
  }

  if (!nonZeroSeen) {
    return { ok: false, error: "Enter at least one non-zero value to make a number." };
  }

  return { ok: true, raw, counts };
}

function regroupCounts(counts) {
  const temp = counts.slice();
  for (let i = temp.length - 1; i > 0; i--) {
    const val = temp[i];
    const carry = Math.floor(val / 10);
    const remain = val % 10;
    temp[i] = remain;
    temp[i - 1] += carry;
  }
  let total = 0;
  for (let i = 0; i < temp.length; i++) {
    total += temp[i] * placeValues[i];
  }
  return { counts: temp, total };
}

function finishToPartitionView(total, countsArray) {
  currentValue = total;
  finalCounts = countsArray ? countsArray.slice() : new Array(placeNames.length).fill(0);
  isInputMode = false;
  challengeRevealed = false;
  currentMode = "explore";
  sliderRow.classList.remove("hidden");
  setSliderEnabled(true);
  returnBtn.classList.remove("hidden");
  setError("");
  updateAll();
}

/* CARRY VISUAL HELPERS ------------------------------------------- */
function getDigitCell(index) {
  const cols = gridEl.querySelectorAll(".pv-column");
  if (index < 0 || index >= cols.length) return null;
  return cols[index].querySelector(".pv-digit");
}

function setDigitCellValue(index, val) {
  const cell = getDigitCell(index);
  if (!cell) return;
  cell.textContent = String(val);
  cell.classList.remove("empty");
}

function showCarryBubble(fromIndex, text, toIndex) {
  const fromCell = getDigitCell(fromIndex);
  if (!fromCell) return;

  const bubble = document.createElement("div");
  bubble.className = "carry-bubble";
  bubble.textContent = text;
  fromCell.appendChild(bubble);

  if (typeof toIndex === "number") {
    const toCell = getDigitCell(toIndex);
    if (toCell) {
      const fromRect = fromCell.getBoundingClientRect();
      const toRect = toCell.getBoundingClientRect();

      const fromCenterX = fromRect.left + fromRect.width / 2;
      const toCenterX   = toRect.left   + toRect.width   / 2;

      const dx = toCenterX - fromCenterX;
      bubble.style.setProperty("--dx", `${dx}px`);
    }
  }

  setTimeout(() => bubble.remove(), 3500);
}

/* SEQUENTIAL REGROUP ANIMATION (FORWARD) ------------------------- */
async function runRegroupAnimation(counts) {
  const temp = counts.slice();
  animationSteps = []; // clear any previous history

  // show the grouped values in the input grid while animating
  const inputs = gridEl.querySelectorAll(".pv-input");
  for (let i = 0; i < temp.length; i++) {
    const val = temp[i];
    if (inputs[i]) {
      inputs[i].value = val === 0 && originalInputs[i] === "" ? "" : String(val);
      updateInputDisplay(i, inputs[i].value);
    }
  }
  refreshImageRowForCounts(temp);

  for (let i = temp.length - 1; i > 0; i--) {
    let val = temp[i];
    if (val <= 9) continue;

    const carry = Math.floor(val / 10);
    const remain = val % 10;
    const leftIndex = i - 1;
    const prevLeft = temp[leftIndex];

    // record this step so we can undo later
    animationSteps.push({
      rightIndex: i,
      leftIndex,
      carry,
      remain,
      prevLeft,
      newLeft: prevLeft + carry
    });

    // update right cell (show 0 if needed)
    temp[i] = remain;
    if (inputs[i]) {
      inputs[i].value = String(remain);
      updateInputDisplay(i, inputs[i].value);
    }
    refreshImageRowForCounts(temp);

    // show carry bubble from right cell
    showCarryBubble(i, carry, leftIndex);
    await delay(900);

    // clear left display and show "prevLeft + carry"
    const leftCell = getDigitCell(leftIndex);
    let ann = null;
    if (leftCell) {
      ann = document.createElement("div");
      ann.className = "carry-annotation";
      ann.textContent = `${prevLeft} + ${carry}`;
      leftCell.appendChild(ann);
    }

    temp[leftIndex] = prevLeft + carry;

    await delay(1200);

    if (ann) ann.remove();

    if (inputs[leftIndex]) {
      inputs[leftIndex].value = String(temp[leftIndex]);
      updateInputDisplay(leftIndex, inputs[leftIndex].value);
    }
    refreshImageRowForCounts(temp);

    await delay(400);
  }

  const { counts: finalCountsAfter, total } = regroupCounts(temp);
  finishToPartitionView(total, finalCountsAfter);

  // only enable undo if there were meaningful regroup steps
  hasAnimated = animationSteps.length > 0;
  animateBtn.textContent = hasAnimated ? "Undo animation" : "Animate";
}

/* REVERSE REGROUP ANIMATION (UNDO) ------------------------------- */
async function runReverseAnimation() {
  if (!hasAnimated || !animationSteps.length) return;

  const temp = finalCounts.slice();

  for (let s = animationSteps.length - 1; s >= 0; s--) {
    const { leftIndex, rightIndex, carry, remain, prevLeft } = animationSteps[s];

    // annotation on the left cell showing the decomposition
    const leftCell = getDigitCell(leftIndex);
    let ann = null;
    if (leftCell) {
      ann = document.createElement("div");
      ann.className = "carry-annotation";
      ann.textContent = `${prevLeft} + ${carry}`;
      leftCell.appendChild(ann);
    }

    await delay(800);

    // left cell returns to prevLeft
    temp[leftIndex] = prevLeft;
    setDigitCellValue(leftIndex, prevLeft);
    refreshImageRowForCounts(temp);

    // carry bubble moves from left to right
    showCarryBubble(leftIndex, carry, rightIndex);
    await delay(900);

    // right cell regains its original multi-digit group value
    const originalRight = carry * 10 + remain;
    temp[rightIndex] = originalRight;
    setDigitCellValue(rightIndex, originalRight);
    refreshImageRowForCounts(temp);

    if (ann) ann.remove();
    await delay(400);
  }

  // we’ve visually undone; now go back to INPUT MODE
  hasAnimated = false;
  animateBtn.textContent = "Animate";

  isInputMode = true;
  currentValue = null;
  sliderRow.classList.add("hidden");
  setSliderEnabled(false);
  resultRow.classList.add("hidden");
  visualsRow.classList.add("hidden");
  returnBtn.classList.add("hidden");
  setError("");

  updateAll();   // re-renders using originalInputs so you can Animate again
}

/* EVENTS ---------------------------------------------------------- */

// Enter: instant regroup, no animation
enterBtn.addEventListener("click", () => {
  if (!isInputMode || isAnimating) return;

  const { ok, raw, counts, error } = readInputCounts();
  if (!ok) {
    setError(error);
    return;
  }

  const { counts: regrouped, total } = regroupCounts(counts);
  originalInputs = raw.slice();
  hasAnimated = false;
  animateBtn.textContent = "Animate";
  finishToPartitionView(total, regrouped);
});

// Animate: forward regroup (from input) or undo (from partition)
animateBtn.addEventListener("click", async () => {
  if (isAnimating) return;

  // if we're in partition view and have an animation history, play it backwards
  if (!isInputMode && hasAnimated) {
    isAnimating = true;
    setError("");
    await runReverseAnimation();
    isAnimating = false;
    return;
  }

  // otherwise, run the forward animation from the grouped input
  if (!isInputMode) return;

  const { ok, raw, counts, error } = readInputCounts();
  if (!ok) {
    setError(error);
    return;
  }

  const needsRegroup = counts.some(c => c > 9);
  originalInputs = raw.slice();
  setError("");
  isAnimating = true;

  if (!needsRegroup) {
    const { counts: regrouped, total } = regroupCounts(counts);
    finishToPartitionView(total, regrouped);
    hasAnimated = false;
    animateBtn.textContent = "Animate";
    isAnimating = false;
    return;
  }

  await runRegroupAnimation(counts);

  isAnimating = false;
});

// Return to input: restore original groups
returnBtn.addEventListener("click", () => {
  if (isAnimating) return;

  isInputMode = true;
  currentValue = null;
  challengeRevealed = false;
  finalCounts = new Array(placeNames.length).fill(0);
  sliderRow.classList.add("hidden");
  setSliderEnabled(false);
  resultRow.classList.add("hidden");
  visualsRow.classList.add("hidden");
  hasAnimated = false;
  animateBtn.textContent = "Animate";
  setError("");
  updateAll();
});

// Reset: clear everything
resetBtn.addEventListener("click", () => {
  if (isAnimating) return;

  isInputMode = true;
  currentMode = "explore";
  currentValue = null;
  challengeRevealed = false;
  originalInputs = new Array(placeNames.length).fill("");
  finalCounts = new Array(placeNames.length).fill(0);
  inputCounts = new Array(placeNames.length).fill(0);
  splitSlider.value = 3;
  sliderRow.classList.add("hidden");
  setSliderEnabled(false);
  resultRow.classList.add("hidden");
  visualsRow.classList.add("hidden");

  leftVisualTitle.textContent = "";
  rightVisualTitle.textContent = "";
  leftImageWrapper.innerHTML = "";
  rightImageWrapper.innerHTML = "";
  leftMultiplier.textContent = "";
  rightMultiplier.textContent = "";

  exploreBtn.classList.add("active");
  challengeBtn.classList.remove("active");
  hasAnimated = false;
  animateBtn.textContent = "Animate";
  setError("");
  updateAll();
});

splitSlider.addEventListener("input", () => {
  if (isInputMode) return;
  if (currentMode === "challenge") challengeRevealed = false;
  updateAll();
});

window.addEventListener("keydown", (e) => {
  if (isInputMode) return;
  if (currentMode !== "explore") return;
  let v = Number(splitSlider.value);
  const maxIndex = placeNames.length - 1;
  if (e.key === "ArrowLeft") {
    e.preventDefault();
    splitSlider.value = Math.max(0, v - 1);
  }
  if (e.key === "ArrowRight") {
    e.preventDefault();
    splitSlider.value = Math.min(maxIndex, v + 1);
  }
  updateAll();
});

function setMode(mode) {
  currentMode = mode;
  exploreBtn.classList.toggle("active", mode === "explore");
  challengeBtn.classList.toggle("active", mode === "challenge");
}

exploreBtn.addEventListener("click", () => {
  if (isInputMode || isAnimating) return;
  setMode("explore");
  challengeRevealed = false;
  updateAll();
});

challengeBtn.addEventListener("click", () => {
  if (isInputMode || isAnimating) return;
  setMode("challenge");
  splitSlider.value = Math.floor(Math.random() * placeNames.length);
  challengeRevealed = false;
  updateAll();
});

flashBtn.addEventListener("click", () => {
  if (isAnimating) return;
  window.location.href = "partition-flash.html";
});

/* INITIAL --------------------------------------------------------- */
setSliderEnabled(false);
renderGrid();
</script>
</body>
</html>
